// Code generated by command: go run asm_avx2.go -out bytes_avx2_amd64.s -stubs bytes_avx2_amd64.go. DO NOT EDIT.

#include "textflag.h"

// func findInChunk(needle []byte, haystack []byte) int64
// Requires: AVX, AVX2, BMI
TEXT ·findInChunk(SB), NOSPLIT, $0-56
	MOVQ haystack_base+24(FP), AX
	MOVQ needle_len+8(FP), CX
	DECQ CX
	MOVQ needle_base+0(FP), DX

	// create vector filled with first and last character
	MOVQ         DX, BX
	ADDQ         CX, BX
	VPBROADCASTB (DX), Y0
	VPBROADCASTB (BX), Y1
	MOVQ         AX, BX
	ADDQ         CX, BX
	VMOVDQU      (AX), Y2
	VMOVDQU      (BX), Y3
	VPCMPEQB     Y0, Y2, Y0
	VPCMPEQB     Y1, Y3, Y1
	VPAND        Y0, Y1, Y0

	// calculate offsets
	VPMOVMSKB Y0, BX
	MOVQ      $-1, SI

	// loop over offsets, ie bit positions
test_offsets_loop:
	CMPL   BX, $0x00
	JE     test_offsets_loop_done
	TZCNTL BX, SI
	MOVQ   AX, DI
	ADDQ   SI, DI

	// test chunk
	// compare two slices
	MOVQ CX, R8
	CMPQ CX, $0x04
	JGE  test_compare_four_bytes

	// compare two slices one byte at a time
	MOVQ DX, R9

test_memcmp_one_loop:
	// loop by one byte
	CMPQ R8, $0x00
	JE   test_memcmp_one_loop_done
	MOVB (R9), R10
	CMPB (DI), R10
	JNE  test_memcmp_one_loop_done
	ADDQ $0x01, DI
	ADDQ $0x01, R9
	DECQ R8
	JMP  test_memcmp_one_loop

test_memcmp_one_loop_done:
	JMP test_memcmp_done

test_compare_four_bytes:
	// compare two slices four bytes at a time
	MOVQ DI, R9
	MOVQ DX, R10
	ADDQ CX, DI
	SUBQ $0x04, DI
	MOVQ DX, R11
	ADDQ CX, R11
	SUBQ $0x04, R11

	// loop by four bytes
test_memcmp_four_loop:
	CMPQ R9, DI
	JGE  test_memcmp_four_loop_done
	MOVL (R10), R12
	CMPL (R9), R12
	JNE  test_memcmp_four_done
	ADDQ $0x04, R9
	ADDQ $0x04, R10
	JMP  test_memcmp_four_loop

test_memcmp_four_loop_done:
	// compare last four bytes
	MOVL (R11), R12
	CMPL (DI), R12
	JNE  test_memcmp_four_done
	XORQ R8, R8

test_memcmp_four_done:
test_memcmp_done:
	// break early on a match
	CMPQ R8, $0x00
	JE   test_chunk_match
	MOVL BX, SI
	DECL SI
	ANDL SI, BX
	JMP  test_offsets_loop

test_offsets_loop_done:
	MOVQ $-1, SI

test_chunk_match:
	MOVQ SI, ret+48(FP)
	RET

// func indexAvx2(haystack []byte, needle []byte) int64
// Requires: AVX, AVX2, BMI
TEXT ·indexAvx2(SB), NOSPLIT, $0-56
	MOVQ needle_base+24(FP), AX
	MOVQ needle_len+32(FP), CX
	DECQ CX
	MOVQ haystack_base+0(FP), DX
	MOVQ DX, BX
	ADDQ haystack_len+8(FP), BX
	MOVQ BX, SI
	SUBQ $0x20, SI
	SUBQ CX, SI
	MOVQ DX, DI

	// create vector filled with first and last character
	MOVQ         AX, R8
	ADDQ         CX, R8
	VPBROADCASTB (AX), Y0
	VPBROADCASTB (R8), Y1

chunk_loop:
	CMPQ     DI, SI
	JG       chunk_loop_end
	MOVQ     DI, R8
	ADDQ     CX, R8
	VMOVDQU  (DI), Y2
	VMOVDQU  (R8), Y3
	VPCMPEQB Y0, Y2, Y2
	VPCMPEQB Y1, Y3, Y3
	VPAND    Y2, Y3, Y2

	// calculate offsets
	VPMOVMSKB Y2, R8
	MOVQ      $-1, R9

	// loop over offsets, ie bit positions
main_offsets_loop:
	CMPL   R8, $0x00
	JE     main_offsets_loop_done
	TZCNTL R8, R9
	MOVQ   DI, R10
	ADDQ   R9, R10

	// test chunk
	// compare two slices
	MOVQ CX, R11
	CMPQ CX, $0x04
	JGE  main_compare_four_bytes

	// compare two slices one byte at a time
	MOVQ AX, R12

main_memcmp_one_loop:
	// loop by one byte
	CMPQ R11, $0x00
	JE   main_memcmp_one_loop_done
	MOVB (R12), R13
	CMPB (R10), R13
	JNE  main_memcmp_one_loop_done
	ADDQ $0x01, R10
	ADDQ $0x01, R12
	DECQ R11
	JMP  main_memcmp_one_loop

main_memcmp_one_loop_done:
	JMP main_memcmp_done

main_compare_four_bytes:
	// compare two slices four bytes at a time
	MOVQ R10, R12
	MOVQ AX, R13
	ADDQ CX, R10
	SUBQ $0x04, R10
	MOVQ AX, R14
	ADDQ CX, R14
	SUBQ $0x04, R14

	// loop by four bytes
main_memcmp_four_loop:
	CMPQ R12, R10
	JGE  main_memcmp_four_loop_done
	MOVL (R13), R15
	CMPL (R12), R15
	JNE  main_memcmp_four_done
	ADDQ $0x04, R12
	ADDQ $0x04, R13
	JMP  main_memcmp_four_loop

main_memcmp_four_loop_done:
	// compare last four bytes
	MOVL (R14), R15
	CMPL (R10), R15
	JNE  main_memcmp_four_done
	XORQ R11, R11

main_memcmp_four_done:
main_memcmp_done:
	// break early on a match
	CMPQ R11, $0x00
	JE   main_chunk_match
	MOVL R8, R9
	DECL R9
	ANDL R9, R8
	JMP  main_offsets_loop

main_offsets_loop_done:
	MOVQ $-1, R9

main_chunk_match:
	// break early when offset is >=0.
	CMPQ R9, $0x00
	JGE  matched
	ADDQ $0x20, DI
	JMP  chunk_loop

matched:
	// adjust the offset and return the true index
	MOVQ DI, AX
	SUBQ DX, AX
	ADDQ R9, AX
	MOVQ AX, ret+48(FP)
	RET

chunk_loop_end:
	// match remaining bytes if any
	CMPQ     DI, BX
	JGE      not_matched
	SUBQ     DI, BX
	CMPQ     BX, CX
	JL       not_enough_bytes_left
	MOVQ     SI, DI
	MOVQ     DI, BX
	ADDQ     CX, BX
	VMOVDQU  (DI), Y2
	VMOVDQU  (BX), Y3
	VPCMPEQB Y0, Y2, Y0
	VPCMPEQB Y1, Y3, Y1
	VPAND    Y0, Y1, Y0

	// calculate offsets
	VPMOVMSKB Y0, BX
	MOVQ      $-1, SI

	// loop over offsets, ie bit positions
remaining_offsets_loop:
	CMPL   BX, $0x00
	JE     remaining_offsets_loop_done
	TZCNTL BX, SI
	MOVQ   DI, R8
	ADDQ   SI, R8

	// test chunk
	// compare two slices
	MOVQ CX, R9
	CMPQ CX, $0x04
	JGE  remaining_compare_four_bytes

	// compare two slices one byte at a time
	MOVQ AX, R10

remaining_memcmp_one_loop:
	// loop by one byte
	CMPQ R9, $0x00
	JE   remaining_memcmp_one_loop_done
	MOVB (R10), R11
	CMPB (R8), R11
	JNE  remaining_memcmp_one_loop_done
	ADDQ $0x01, R8
	ADDQ $0x01, R10
	DECQ R9
	JMP  remaining_memcmp_one_loop

remaining_memcmp_one_loop_done:
	JMP remaining_memcmp_done

remaining_compare_four_bytes:
	// compare two slices four bytes at a time
	MOVQ R8, R10
	MOVQ AX, R11
	ADDQ CX, R8
	SUBQ $0x04, R8
	MOVQ AX, R12
	ADDQ CX, R12
	SUBQ $0x04, R12

	// loop by four bytes
remaining_memcmp_four_loop:
	CMPQ R10, R8
	JGE  remaining_memcmp_four_loop_done
	MOVL (R11), R13
	CMPL (R10), R13
	JNE  remaining_memcmp_four_done
	ADDQ $0x04, R10
	ADDQ $0x04, R11
	JMP  remaining_memcmp_four_loop

remaining_memcmp_four_loop_done:
	// compare last four bytes
	MOVL (R12), R13
	CMPL (R8), R13
	JNE  remaining_memcmp_four_done
	XORQ R9, R9

remaining_memcmp_four_done:
remaining_memcmp_done:
	// break early on a match
	CMPQ R9, $0x00
	JE   remaining_chunk_match
	MOVL BX, SI
	DECL SI
	ANDL SI, BX
	JMP  remaining_offsets_loop

remaining_offsets_loop_done:
	MOVQ $-1, SI

remaining_chunk_match:
	MOVQ SI, R9
	JMP  match_remaining_done

not_enough_bytes_left:
	MOVQ $-1, R9

match_remaining_done:
	CMPQ R9, $0x00
	JGE  matched

not_matched:
	MOVQ R9, ret+48(FP)
	RET
