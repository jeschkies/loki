// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: clients/pkg/promtail/targets/tokio/proto/async_ops/async_ops.proto

package async_ops

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	common "github.com/grafana/loki/clients/pkg/promtail/targets/tokio/proto/common"
	google "github.com/grafana/loki/clients/pkg/promtail/targets/tokio/proto/google"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// An AsyncOp state update.
//
// An async operation is a an operation that is associated with a resource
// This could, for example, be a a read or write on a TCP stream or a receive operation on
// a channel.
type AsyncOpUpdate struct {
	// A list of new async operations that were created since the last `AsyncOpUpdate`
	// was sent. Note that the fact that an async operation has been created
	// does not mean that is has been polled or is being polled. This information
	// is reflected in the Stats of the operation.
	NewAsyncOps []*AsyncOp `protobuf:"bytes,1,rep,name=new_async_ops,json=newAsyncOps,proto3" json:"new_async_ops,omitempty"`
	// Any async op stats that have changed since the last update.
	StatsUpdate map[uint64]*Stats `protobuf:"bytes,2,rep,name=stats_update,json=statsUpdate,proto3" json:"stats_update,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AsyncOpUpdate) Reset()      { *m = AsyncOpUpdate{} }
func (*AsyncOpUpdate) ProtoMessage() {}
func (*AsyncOpUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_1cdbb1340b25742f, []int{0}
}
func (m *AsyncOpUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsyncOpUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AsyncOpUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AsyncOpUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsyncOpUpdate.Merge(m, src)
}
func (m *AsyncOpUpdate) XXX_Size() int {
	return m.Size()
}
func (m *AsyncOpUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_AsyncOpUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_AsyncOpUpdate proto.InternalMessageInfo

func (m *AsyncOpUpdate) GetNewAsyncOps() []*AsyncOp {
	if m != nil {
		return m.NewAsyncOps
	}
	return nil
}

func (m *AsyncOpUpdate) GetStatsUpdate() map[uint64]*Stats {
	if m != nil {
		return m.StatsUpdate
	}
	return nil
}

type AsyncOp struct {
	// The async op's ID.
	//
	// This uniquely identifies this op across all *currently live*
	// ones.
	Id *common.Id `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The numeric ID of the op's `Metadata`.
	//
	// This identifies the `Metadata` that describes the `tracing` span
	// corresponding to this async op. The metadata for this ID will have been sent
	// in a prior `RegisterMetadata` message.
	Metadata *common.MetaId `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// The source of this async operation. Most commonly this should be the name
	// of the method where the instantiation of this op has happened.
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *AsyncOp) Reset()      { *m = AsyncOp{} }
func (*AsyncOp) ProtoMessage() {}
func (*AsyncOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_1cdbb1340b25742f, []int{1}
}
func (m *AsyncOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AsyncOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AsyncOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AsyncOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AsyncOp.Merge(m, src)
}
func (m *AsyncOp) XXX_Size() int {
	return m.Size()
}
func (m *AsyncOp) XXX_DiscardUnknown() {
	xxx_messageInfo_AsyncOp.DiscardUnknown(m)
}

var xxx_messageInfo_AsyncOp proto.InternalMessageInfo

func (m *AsyncOp) GetId() *common.Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *AsyncOp) GetMetadata() *common.MetaId {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *AsyncOp) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

type Stats struct {
	// Timestamp of when the async op has been created.
	CreatedAt *google.Timestamp `protobuf:"bytes,1,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Timestamp of when the async op was dropped.
	DroppedAt *google.Timestamp `protobuf:"bytes,2,opt,name=dropped_at,json=droppedAt,proto3" json:"dropped_at,omitempty"`
	// The resource Id this `AsyncOp` is associated with. Note that both
	// `resource_id` and `task_id` can be None if this async op has not been polled yet
	ResourceId *common.Id `protobuf:"bytes,3,opt,name=resource_id,json=resourceId,proto3" json:"resource_id,omitempty"`
	// The Id of the task that is awaiting on this op.
	TaskId *common.Id `protobuf:"bytes,4,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// Contains the operation poll stats.
	PollStats *common.PollStats `protobuf:"bytes,5,opt,name=poll_stats,json=pollStats,proto3" json:"poll_stats,omitempty"`
}

func (m *Stats) Reset()      { *m = Stats{} }
func (*Stats) ProtoMessage() {}
func (*Stats) Descriptor() ([]byte, []int) {
	return fileDescriptor_1cdbb1340b25742f, []int{2}
}
func (m *Stats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stats.Merge(m, src)
}
func (m *Stats) XXX_Size() int {
	return m.Size()
}
func (m *Stats) XXX_DiscardUnknown() {
	xxx_messageInfo_Stats.DiscardUnknown(m)
}

var xxx_messageInfo_Stats proto.InternalMessageInfo

func (m *Stats) GetCreatedAt() *google.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Stats) GetDroppedAt() *google.Timestamp {
	if m != nil {
		return m.DroppedAt
	}
	return nil
}

func (m *Stats) GetResourceId() *common.Id {
	if m != nil {
		return m.ResourceId
	}
	return nil
}

func (m *Stats) GetTaskId() *common.Id {
	if m != nil {
		return m.TaskId
	}
	return nil
}

func (m *Stats) GetPollStats() *common.PollStats {
	if m != nil {
		return m.PollStats
	}
	return nil
}

func init() {
	proto.RegisterType((*AsyncOpUpdate)(nil), "async_ops.AsyncOpUpdate")
	proto.RegisterMapType((map[uint64]*Stats)(nil), "async_ops.AsyncOpUpdate.StatsUpdateEntry")
	proto.RegisterType((*AsyncOp)(nil), "async_ops.AsyncOp")
	proto.RegisterType((*Stats)(nil), "async_ops.Stats")
}

func init() {
	proto.RegisterFile("clients/pkg/promtail/targets/tokio/proto/async_ops/async_ops.proto", fileDescriptor_1cdbb1340b25742f)
}

var fileDescriptor_1cdbb1340b25742f = []byte{
	// 505 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x4f, 0x8b, 0xd3, 0x4c,
	0x18, 0xcf, 0xb4, 0xdb, 0xee, 0xdb, 0xc9, 0xbb, 0x52, 0x47, 0x5c, 0x4a, 0x0f, 0x43, 0xa9, 0x20,
	0x55, 0x21, 0x91, 0x0a, 0x22, 0xde, 0xba, 0xe0, 0xa1, 0xa2, 0xb8, 0x44, 0xbd, 0x78, 0x09, 0xb3,
	0x9d, 0x31, 0x0e, 0x4d, 0x32, 0x21, 0xf3, 0xd4, 0xa5, 0xb7, 0xfd, 0x08, 0x7e, 0x0c, 0x3f, 0x8a,
	0xc7, 0x1e, 0xf7, 0x68, 0xd3, 0x83, 0xde, 0xdc, 0x8f, 0x20, 0x93, 0x99, 0xb6, 0xea, 0xe2, 0xc1,
	0x53, 0x9e, 0xfc, 0x9e, 0xdf, 0xbf, 0xcc, 0x10, 0x7c, 0x32, 0x4b, 0xa5, 0xc8, 0x41, 0x87, 0xc5,
	0x3c, 0x09, 0x8b, 0x52, 0x65, 0xc0, 0x64, 0x1a, 0x02, 0x2b, 0x13, 0x01, 0x3a, 0x04, 0x35, 0x97,
	0xca, 0xc0, 0xa0, 0x42, 0xa6, 0x97, 0xf9, 0x2c, 0x56, 0x85, 0xde, 0x4f, 0x41, 0xbd, 0x21, 0x9d,
	0x1d, 0xd0, 0x3f, 0x4e, 0x94, 0x4a, 0x52, 0x11, 0x82, 0xcc, 0x84, 0x06, 0x96, 0x15, 0x96, 0xd2,
	0xbf, 0xed, 0x70, 0xbe, 0x28, 0x19, 0x48, 0x95, 0x3b, 0xf8, 0xd6, 0x4c, 0x65, 0x99, 0xca, 0x43,
	0xfb, 0xb0, 0xe0, 0xf0, 0x1b, 0xc2, 0x47, 0x13, 0xe3, 0xf8, 0xaa, 0x78, 0x5b, 0x70, 0x06, 0x82,
	0x3c, 0xc6, 0x47, 0xb9, 0x38, 0x8f, 0x77, 0x31, 0x3d, 0x34, 0x68, 0x8e, 0xfc, 0x31, 0x09, 0xf6,
	0x4d, 0x9c, 0x20, 0xf2, 0x73, 0x71, 0xee, 0x66, 0x4d, 0x5e, 0xe0, 0xff, 0x35, 0x30, 0xd0, 0xf1,
	0xa2, 0xf6, 0xe9, 0x35, 0x6a, 0xd9, 0xbd, 0xeb, 0x32, 0x9b, 0x13, 0xbc, 0x36, 0x64, 0x3b, 0x3f,
	0xcb, 0xa1, 0x5c, 0x46, 0xbe, 0xde, 0x23, 0xfd, 0x53, 0xdc, 0xfd, 0x93, 0x40, 0xba, 0xb8, 0x39,
	0x17, 0xcb, 0x1e, 0x1a, 0xa0, 0xd1, 0x41, 0x64, 0x46, 0x72, 0x17, 0xb7, 0x3e, 0xb2, 0x74, 0x61,
	0xc2, 0xd0, 0xc8, 0x1f, 0x77, 0x7f, 0x09, 0xab, 0xd5, 0x91, 0x5d, 0x3f, 0x6d, 0x3c, 0x41, 0x43,
	0x89, 0x0f, 0x5d, 0x01, 0xd2, 0xc7, 0x0d, 0xc9, 0x6b, 0x1f, 0x7f, 0x8c, 0x03, 0x77, 0x1e, 0x53,
	0x1e, 0x35, 0x24, 0x27, 0xf7, 0xf1, 0x7f, 0x99, 0x00, 0xc6, 0x19, 0x30, 0xe7, 0x7a, 0x63, 0xcb,
	0x78, 0x29, 0x80, 0x4d, 0x79, 0xb4, 0xdb, 0x93, 0x63, 0xdc, 0xd6, 0x6a, 0x51, 0xce, 0x44, 0xaf,
	0x39, 0x40, 0xa3, 0x4e, 0xe4, 0xde, 0x86, 0x3f, 0x10, 0x6e, 0xd5, 0xf9, 0xe4, 0x21, 0xc6, 0xb3,
	0x52, 0x30, 0x10, 0x3c, 0x66, 0xe0, 0x12, 0x6f, 0x06, 0xf6, 0x7e, 0x82, 0x37, 0xdb, 0x7b, 0x8b,
	0x3a, 0x8e, 0x34, 0x01, 0xa3, 0xe0, 0xa5, 0x2a, 0x0a, 0xab, 0x68, 0xfc, 0x55, 0xe1, 0x48, 0x13,
	0x20, 0x0f, 0xb0, 0x5f, 0x0a, 0x9b, 0x1c, 0x4b, 0x5e, 0x57, 0xf9, 0xfd, 0xb3, 0xf0, 0x76, 0x3d,
	0xe5, 0xe4, 0x0e, 0x3e, 0x04, 0xa6, 0xe7, 0x86, 0x78, 0x70, 0x8d, 0xd8, 0x36, 0xab, 0x29, 0x37,
	0x1d, 0x0a, 0x95, 0xa6, 0x71, 0x7d, 0x21, 0xbd, 0x96, 0xeb, 0xe0, 0x78, 0xa7, 0x2a, 0x4d, 0xed,
	0xe1, 0x76, 0x8a, 0xed, 0x78, 0x72, 0x81, 0x56, 0x6b, 0xea, 0x5d, 0xae, 0xa9, 0x77, 0xb5, 0xa6,
	0xe8, 0xa2, 0xa2, 0xe8, 0x73, 0x45, 0xd1, 0x97, 0x8a, 0xa2, 0x55, 0x45, 0xd1, 0xd7, 0x8a, 0xa2,
	0xef, 0x15, 0xf5, 0xae, 0x2a, 0x8a, 0x3e, 0x6d, 0xa8, 0xb7, 0xda, 0x50, 0xef, 0x72, 0x43, 0xbd,
	0x77, 0xcf, 0x13, 0x09, 0x1f, 0x16, 0x67, 0xc6, 0x3a, 0x4c, 0x4a, 0xf6, 0x9e, 0xe5, 0x2c, 0x4c,
	0xd5, 0x5c, 0x86, 0xff, 0xfe, 0xa3, 0x9c, 0xb5, 0x6b, 0xe0, 0xd1, 0xcf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xc1, 0xbd, 0x49, 0x07, 0x65, 0x03, 0x00, 0x00,
}

func (this *AsyncOpUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AsyncOpUpdate)
	if !ok {
		that2, ok := that.(AsyncOpUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.NewAsyncOps) != len(that1.NewAsyncOps) {
		return false
	}
	for i := range this.NewAsyncOps {
		if !this.NewAsyncOps[i].Equal(that1.NewAsyncOps[i]) {
			return false
		}
	}
	if len(this.StatsUpdate) != len(that1.StatsUpdate) {
		return false
	}
	for i := range this.StatsUpdate {
		if !this.StatsUpdate[i].Equal(that1.StatsUpdate[i]) {
			return false
		}
	}
	return true
}
func (this *AsyncOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AsyncOp)
	if !ok {
		that2, ok := that.(AsyncOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	return true
}
func (this *Stats) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Stats)
	if !ok {
		that2, ok := that.(Stats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.DroppedAt.Equal(that1.DroppedAt) {
		return false
	}
	if !this.ResourceId.Equal(that1.ResourceId) {
		return false
	}
	if !this.TaskId.Equal(that1.TaskId) {
		return false
	}
	if !this.PollStats.Equal(that1.PollStats) {
		return false
	}
	return true
}
func (this *AsyncOpUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&async_ops.AsyncOpUpdate{")
	if this.NewAsyncOps != nil {
		s = append(s, "NewAsyncOps: "+fmt.Sprintf("%#v", this.NewAsyncOps)+",\n")
	}
	keysForStatsUpdate := make([]uint64, 0, len(this.StatsUpdate))
	for k, _ := range this.StatsUpdate {
		keysForStatsUpdate = append(keysForStatsUpdate, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForStatsUpdate)
	mapStringForStatsUpdate := "map[uint64]*Stats{"
	for _, k := range keysForStatsUpdate {
		mapStringForStatsUpdate += fmt.Sprintf("%#v: %#v,", k, this.StatsUpdate[k])
	}
	mapStringForStatsUpdate += "}"
	if this.StatsUpdate != nil {
		s = append(s, "StatsUpdate: "+mapStringForStatsUpdate+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AsyncOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&async_ops.AsyncOp{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "Source: "+fmt.Sprintf("%#v", this.Source)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Stats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&async_ops.Stats{")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.DroppedAt != nil {
		s = append(s, "DroppedAt: "+fmt.Sprintf("%#v", this.DroppedAt)+",\n")
	}
	if this.ResourceId != nil {
		s = append(s, "ResourceId: "+fmt.Sprintf("%#v", this.ResourceId)+",\n")
	}
	if this.TaskId != nil {
		s = append(s, "TaskId: "+fmt.Sprintf("%#v", this.TaskId)+",\n")
	}
	if this.PollStats != nil {
		s = append(s, "PollStats: "+fmt.Sprintf("%#v", this.PollStats)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAsyncOps(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AsyncOpUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsyncOpUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsyncOpUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatsUpdate) > 0 {
		for k := range m.StatsUpdate {
			v := m.StatsUpdate[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintAsyncOps(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintAsyncOps(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAsyncOps(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NewAsyncOps) > 0 {
		for iNdEx := len(m.NewAsyncOps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewAsyncOps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAsyncOps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AsyncOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AsyncOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AsyncOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintAsyncOps(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsyncOps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsyncOps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Stats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PollStats != nil {
		{
			size, err := m.PollStats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsyncOps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TaskId != nil {
		{
			size, err := m.TaskId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsyncOps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ResourceId != nil {
		{
			size, err := m.ResourceId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsyncOps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DroppedAt != nil {
		{
			size, err := m.DroppedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsyncOps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAsyncOps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAsyncOps(dAtA []byte, offset int, v uint64) int {
	offset -= sovAsyncOps(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AsyncOpUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NewAsyncOps) > 0 {
		for _, e := range m.NewAsyncOps {
			l = e.Size()
			n += 1 + l + sovAsyncOps(uint64(l))
		}
	}
	if len(m.StatsUpdate) > 0 {
		for k, v := range m.StatsUpdate {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAsyncOps(uint64(l))
			}
			mapEntrySize := 1 + sovAsyncOps(uint64(k)) + l
			n += mapEntrySize + 1 + sovAsyncOps(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AsyncOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovAsyncOps(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAsyncOps(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovAsyncOps(uint64(l))
	}
	return n
}

func (m *Stats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovAsyncOps(uint64(l))
	}
	if m.DroppedAt != nil {
		l = m.DroppedAt.Size()
		n += 1 + l + sovAsyncOps(uint64(l))
	}
	if m.ResourceId != nil {
		l = m.ResourceId.Size()
		n += 1 + l + sovAsyncOps(uint64(l))
	}
	if m.TaskId != nil {
		l = m.TaskId.Size()
		n += 1 + l + sovAsyncOps(uint64(l))
	}
	if m.PollStats != nil {
		l = m.PollStats.Size()
		n += 1 + l + sovAsyncOps(uint64(l))
	}
	return n
}

func sovAsyncOps(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAsyncOps(x uint64) (n int) {
	return sovAsyncOps(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AsyncOpUpdate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNewAsyncOps := "[]*AsyncOp{"
	for _, f := range this.NewAsyncOps {
		repeatedStringForNewAsyncOps += strings.Replace(f.String(), "AsyncOp", "AsyncOp", 1) + ","
	}
	repeatedStringForNewAsyncOps += "}"
	keysForStatsUpdate := make([]uint64, 0, len(this.StatsUpdate))
	for k, _ := range this.StatsUpdate {
		keysForStatsUpdate = append(keysForStatsUpdate, k)
	}
	github_com_gogo_protobuf_sortkeys.Uint64s(keysForStatsUpdate)
	mapStringForStatsUpdate := "map[uint64]*Stats{"
	for _, k := range keysForStatsUpdate {
		mapStringForStatsUpdate += fmt.Sprintf("%v: %v,", k, this.StatsUpdate[k])
	}
	mapStringForStatsUpdate += "}"
	s := strings.Join([]string{`&AsyncOpUpdate{`,
		`NewAsyncOps:` + repeatedStringForNewAsyncOps + `,`,
		`StatsUpdate:` + mapStringForStatsUpdate + `,`,
		`}`,
	}, "")
	return s
}
func (this *AsyncOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AsyncOp{`,
		`Id:` + strings.Replace(fmt.Sprintf("%v", this.Id), "Id", "common.Id", 1) + `,`,
		`Metadata:` + strings.Replace(fmt.Sprintf("%v", this.Metadata), "MetaId", "common.MetaId", 1) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Stats) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Stats{`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "google.Timestamp", 1) + `,`,
		`DroppedAt:` + strings.Replace(fmt.Sprintf("%v", this.DroppedAt), "Timestamp", "google.Timestamp", 1) + `,`,
		`ResourceId:` + strings.Replace(fmt.Sprintf("%v", this.ResourceId), "Id", "common.Id", 1) + `,`,
		`TaskId:` + strings.Replace(fmt.Sprintf("%v", this.TaskId), "Id", "common.Id", 1) + `,`,
		`PollStats:` + strings.Replace(fmt.Sprintf("%v", this.PollStats), "PollStats", "common.PollStats", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAsyncOps(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AsyncOpUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsyncOps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsyncOpUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsyncOpUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAsyncOps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAsyncOps = append(m.NewAsyncOps, &AsyncOp{})
			if err := m.NewAsyncOps[len(m.NewAsyncOps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatsUpdate == nil {
				m.StatsUpdate = make(map[uint64]*Stats)
			}
			var mapkey uint64
			var mapvalue *Stats
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAsyncOps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAsyncOps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAsyncOps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAsyncOps
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthAsyncOps
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Stats{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAsyncOps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAsyncOps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StatsUpdate[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsyncOps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsyncOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsyncOps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsyncOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsyncOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &common.Id{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &common.MetaId{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsyncOps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAsyncOps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &google.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DroppedAt == nil {
				m.DroppedAt = &google.Timestamp{}
			}
			if err := m.DroppedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceId == nil {
				m.ResourceId = &common.Id{}
			}
			if err := m.ResourceId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaskId == nil {
				m.TaskId = &common.Id{}
			}
			if err := m.TaskId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PollStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAsyncOps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PollStats == nil {
				m.PollStats = &common.PollStats{}
			}
			if err := m.PollStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAsyncOps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAsyncOps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAsyncOps(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAsyncOps
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAsyncOps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAsyncOps
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAsyncOps
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAsyncOps
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAsyncOps(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAsyncOps
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAsyncOps = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAsyncOps   = fmt.Errorf("proto: integer overflow")
)
